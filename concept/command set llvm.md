## Набор команд виртуальной машины низкого уровня
набор команд виртуальной машины низкого уровня (eng:command set low level virtual machine)
## Описание
Виртуальный набор инструкций LLVM предназначен для низкоуровневого представления с поддержкой высокоуровневого анализа и
преобразования. Для достижения этих целей он предоставляет обширную информацию независимого от языка типа обо всех значениях.
В программе, выделяет память непосредственно компилятору и специально разработан, чтобы иметь несколько специальных
случаи. В этом разделе сначала представлен обзор архитектуры LLVM, а затем обсуждаются основные функции
Виртуальный набор инструкций LLVM.
## Обзор архитектуры LLVM
Набор инструкций LLVM представляет собой виртуальную архитектуру, которая захватывает ключевые операции обычных процессоров,
но избегает специфических для машины ограничений, таких как физические регистры, конвейеры, соглашения о низкоуровневых вызовах или ловушки.
LLVM предоставляет бесконечный набор типизированных виртуальных регистров, которые могут хранить значения примитивных типов (целочисленные, плавающие
точки или значения указателя). Виртуальные регистры имеют форму Static Single Assignment (SSA), которая широко используется
представление для оптимизации компилятора. 
Программы LLVM передают значения между виртуальными регистрами и памятью исключительно посредством операций загрузки и сохранения,
с помощью типизированных указателей.

Память разделена на глобальную область, стек и кучу (где функции в программе рассматриваются как глобальные объекты). Объекты в стеке и куче выделяются с помощью инструкций alloca и malloc.
соответственно, и доступ к ним осуществляется через значения указателя, возвращаемые этими операциями. Объекты стека размещаются в
кадр стека текущей функции и автоматически освобождаются, когда управление покидает функцию. Объекты кучи должны
быть явно освобожден с помощью свободной инструкции.

Обратите внимание, что LLVM — это виртуальный набор инструкций: он не определяет функции среды выполнения и операционной системы, такие как ввод-вывод,
управление памятью (в частности сборка мусора), сигналы и многие другие. Некоторые вопросы, которые относятся к
набор инструкций и может быть добавлен в будущем, включая поддержку мультимедийных инструкций (например, пакетных операций),
предикативные инструкции и явный параллелизм.
## Трехадресный код
Трехадресный код был предпочтительным представлением для архитектур RISC и независимого от языка компилятора.
оптимизация на долгие годы. По духу он очень близок к машинному коду, с небольшим количеством простых, ортогональных
операции. Трехадресный код можно легко сжать, что позволяет создавать файлы LLVM высокой плотности.
Большинство операций LLVM, включая все арифметические и логические операции, выполняются в 3-адресной форме, т. е. они занимают один адрес.
или два операнда и дают один результат. 

LLVM включает в себя стандартный и довольно ортогональный набор арифметических и
логические операции: add, sub, mul, div, rem, not, and, or, xor, shl, shr и setcc. Последний (setcc)
на самом деле набор инструкций сравнения с различными операторами (например, seteq, setlt и т. д.), которые производят
логический результат. Помимо простых двоичных инструкций, некоторые инструкции могут принимать 0, 3 и более или переменное число.
операндов. Важные примеры включают инструкции вызова и инструкцию phi, используемую для перевода кода в форму SSA.
Ключевым моментом является то, что инструкции LLVM полиморфны, т. е. одна инструкция, такая как add, может работать с несколькими командами.
различные типы операндов. Это значительно уменьшает количество различных кодов операций. В частности, мы не требуем
разные коды операций для операций над целыми числами со знаком и без знака, значениями с плавающей запятой одинарной или двойной точности,
арифметические или логические сдвиги и т. д. Типы операндов автоматически определяют семантику операции и
тип результата и должен следовать строгим правилам типов.

Например, вот несколько простых операций LLVM:
```
 #%X = div int 4, 9                                 ; Signed integer division
 %Y = div uint 12, 4                                ; Unsigned integer division
 %cond = seteq int %X, 8                            ; Produces a boolean value
 br bool %cond, label %True, label %False
True:
 ...
```
## Статическая форма единого назначения
LLVM использует форму Static Single Assignment (SSA) в качестве основного представления кода. Говорят, что программа находится в SSA
форме, если каждая из его переменных определена ровно один раз, и каждое использование переменной определяется определением этой переменной.
Форма SSA значительно упрощает оптимизацию многих потоков данных, потому что только одно определение может найти конкретное применение.
значения, и найти это определение тривиально. Он также позволяет использовать быстрые нечувствительные к потоку алгоритмы для достижения многих из
преимущества алгоритмов, чувствительных к потоку (иногда называемых свойством разреженности).

Одним из следствий свойства единственного определения является то, что каждая инструкция, вычисляющая значение (например, add int
%x, %y) неявно создает новый виртуальный регистр, содержащий это значение. Значение может иметь явное имя (например,
%z = добавить...); если нет, анализатор LLVM автоматически присваивает уникальное имя. Это свойство позволяет «использовать»
в LLVM, чтобы ссылаться непосредственно на операцию, которая вычисляет значение, обеспечивая эффективный обход информации об использовании.
Если принять во внимание поток управления, простого переименования переменных недостаточно, чтобы код соответствовал допустимому SSA.
форма. Для обработки слияния потока управления форма SSA определяет функцию φ, которая используется для выбора входящего значения,
в зависимости от того, из какого базового блока поступил поток управления. LLVM предоставляет инструкцию phi, которая соответствует
SSA φ-узел. 
```
<result> = phi <type> [<val0>, <label0>], ... , [<valN>, <labelN>].
```

result is assigned the value val0 if control reaches this instruction from the basic block labelled label0, val1
if control reaches here from basic block label1, and so on. All the phi instructions in a basic block must appear at
the beginning of the basic block. For example the loop of this C function:
```
int pow(int M, unsigned N) {
unsigned i; int Result = 1;
for (i = 0; i != N; ++i)
Result *= M;
return Result;
}
```

переводится в LLVM как:
```
Loop:
%result = phi int [ %nextres, %Loop ], [ 1, %LoopHeader ]
%i = phi uint [ %nexti, %Loop ], [ 0, %LoopHeader ]
%nextres = mul int %result, %M                        ; Result *= M
%nexti = add uint %i, 1                               ; i = i + 1
%cond = setne uint %nexti, %N                         ; i != N
br bool %cond2, label %Loop, label %Exit
```

Как отмечалось ранее, виртуальные регистры в LLVM имеют форму SSA, а значения в памяти — нет. Это упрощает
преобразований (поскольку скаляры не могут иметь псевдонимы), за счет небольшого усложнения для загрузки и сохранения движения
(переупорядочивание операций загрузки и сохранения по-прежнему требует анализа зависимости указателя и массива).

## Информация о типе
LLVM — это строго типизированное представление, где каждое значение SSA или ячейка памяти имеют связанный с ним тип, и все
операции подчиняются строгим правилам типов. Информация этого типа позволяет выполнять широкий класс высокоуровневых преобразований на низкоуровневых.
код. Кроме того, несоответствие типов можно использовать для обнаружения ошибок в оптимизации с помощью средства проверки согласованности LLVM.
Система типов LLVM включает в себя независимые от исходного языка примитивные типы (void, bool, signed и unsigned).
целые числа от 8 до 64 бит, значения с плавающей запятой одинарной и двойной точности и непрозрачные) и конструктивные типы
(указатели, массивы, структуры, функции). Эти типы являются независимыми от языка представлениями данных, которые отображаются на
из языковых типов более высокого уровня. Например, классы в C++ с наследованием и виртуальными методами могут быть представлены
использование структур для значений данных и таблицы типизированных функций с косвенными вызовами функций для наследования. Это позволяет
многие оптимизации, не зависящие от языка, и даже некоторые высокоуровневые оптимизации (например, разрешение виртуальных функций)
для выполнения в коде LLVM.

Некоторые примеры, иллюстрирующие типы в LLVM:
```
%arrayty = [2 x [3 x [4 x uint]]]            ; 2x3x4 array of unsigned integer values
%aptr = [4 x int]*                           ; Pointer to array of four int values
%funptr = float (int, int *) *               ; Pointer to a function that takes an int and a
                                             ; pointer to int, returning float.
%strty = { float, %funptr }                  ; A structure, where the first element is a
                                             ; float and the second element is the %funptr
                                             ; pointer to function type defined previously
```

Все инструкции LLVM строго типизированы, и все имеют ограничения на операнды для упрощения преобразований.
и сохранить правильность типа (Кроме того, эти ограничения делают код LLVM более компактным. Например, инструкция добавления требует, чтобы оба операнда были одного типа, что должно быть
арифметический (т. е. целочисленный или с плавающей запятой) тип, и он создает значение этого типа. Инструкция загрузки требует
операнд-указатель для загрузки. Инструкция сохранения требует значения некоторого типа (скажем, τ) для сохранения и указателя на
store в, который должен быть указателем на этот тип (τ*). 

Некоторые примеры неправильно сформированного кода:
```
uint %testfunc() {
%v = load int 4 ; Must load through a pointer
store int 42, float* %fptr                              ; Cannot store int through float pointer
%Val = add int %Val, 0                                  ; Definition does not dominate use
ret int* null                                           ; Cannot return int* from function returning uint
}
```
Информация о типе позволяет легко извлекать высокоуровневую информацию из низкоуровневого кода, что позволяет создавать новые
преобразования во время компоновки. Однако для этого должна быть предусмотрена возможность безопасного доступа к полям данных.
в памяти. По этой причине критически важной инструкцией в LLVM (для обеспечения безопасности типов) является getelementptr
инструкция.

## Типобезопасная арифметика указателей: инструкция getelementptr
Инструкция getelementptr используется для вычисления адреса подэлемента агрегированной структуры данных.
типобезопасным способом. Учитывая указатель на структуру и номер поля, инструкция getelementptr возвращает
указатель на поле. Учитывая указатель на массив и номер элемента, инструкция возвращает указатель на массив.
указанный элемент. В дополнение к единичному индексированию несколько индексов могут выполняться одновременно с помощью одного
Инструкция getelementptr.

Приведенный ниже пример представляет собой сложный тестовый набор C, предназначенный для краткой иллюстрации лексической структуры LLVM.
система типов и инструкция getelementptr. Тестовый пример определяет два типа структуры и функцию, которая
выполняет сложную индексацию:
```
struct RT { /* Structure with complex types */
char A;
int B[10][20];
char C;
};
struct ST {
int X;
double Y;
struct RT Z; /* ST contains an instance of RT embedded in it */
};
int *foo(struct ST *s) {
return &s[1].Z.B[5][13];
}
```
Приведенный ниже код LLVM представляет собой версию кода, сгенерированного нашим интерфейсом C, с добавленными комментариями LLVM:
```
%RT = type { sbyte, [10 x [20 x int]], sbyte }
%ST = type { int, double, %RT }
; Define function ’foo’, returning an ’int*’, taking an ’ST*’:
int* %foo(%ST* %s) {
; Perform the indexing...
%tmp = getelementptr %ST* %s, uint 1, ubyte 2, ubyte 1, uint 5, uint 13
ret int* %tmp ; Return the computed value
}
```
Этот код LLVM показывает, что идентификаторы LLVM (имена типов и значений) начинаются с символа % (для предотвращения
коллизии пространств имен с зарезервированными словами), показывает несколько примеров сложных вложенных типов и показывает LLVM.
определение функции. Кроме того, он показывает, насколько полезны именованные типы для ручной проверки кода (без использования символьных
имена, предоставленные компилятором C, все типы будут расширены внутри, что сделает их менее управляемыми).

## Отличие безопасного и небезопасного кода: инструкция приведения
Есть две основные причины, по которым в программах может потребоваться преобразование типов: (а) явное преобразование значения
из одного типа в другой, что может потребовать или может потребовать манипулирования данными (например, целое число с плавающей запятой или знаковое
целое число в беззнаковое) и (b) повторная интерпретация данных одного типа как данных другого типа (например, обработка данных в памяти как
линейная последовательность байтов вместо массива целых чисел).

В LLVM преобразования типов могут происходить только одним тщательно контролируемым способом: инструкцией приведения типов. В ролях
Инструкция преобразует значение из одного типа в другой. Некоторые примеры:
```
%Y = cast int %X to double                       ; requires data conversion
%J = cast int %I to long                         ; may require data conversion
%J = cast int %I to uint                         ; no data conversion needed
%q = cast int %pd to double*                     ; no data conversion needed; may be unsafe
%r = cast void* %pi to QItem*                    ; no data conversion needed; may be unsafe
```
Инструкция приведения заменяет типичные инструкции расширения знака (знаковые и беззнаковые типы различаются),
а также инструкции преобразования целых чисел в числа с плавающей запятой. Приведение также используется для операций, которые не изменяют данные, как
ну, например, преобразование целого числа со знаком в целое число без знака того же размера.
Поскольку LLVM задуман как низкоуровневый набор инструкций общего назначения, он должен представлять как «типобезопасный», так и
«типобезопасные» программы для произвольных языков высокого уровня.

Тем не менее, различая безопасные и небезопасные
операции важны, потому что многие оптимизации, ориентированные на память, могут быть разрешены только для безопасных программ.
Мы считаем, что программа LLVM безопасна с точки зрения типов, если ни одна инструкция приведения не преобразует тип, не являющийся указателем, в указатель.
тип или указатель одного типа на указатель другого типа (другими словами, не допускается приведение к типу указателя). В
В приведенном выше примере последние две инструкции приведения небезопасны. Такие приведения указателей — единственный способ, с помощью которого операции
Второй тип выше (который пересчитывает данные в память) может быть закодирован в LLVM.
Некоторые небезопасные программы по этому определению действительно небезопасны: их результаты зависят от конкретного расположения их данных.
структуры в памяти. К сожалению, есть один общий класс программ, для которых это определение слишком консервативно:
многие языки реализуют контейнерные типы (например, хеш-таблицу в C) с общими ссылочными типами (например, void* в
C), которые необходимо привести к фактическому ссылочному типу при доступе к ним. Такие программы могут быть вполне безопасными, но
требует дополнительного анализа, чтобы доказать свою безопасность. Без такого анализа операции литья не могут быть устранены и
программа должна рассматриваться как небезопасная. В будущем у нас запланирован проект по расширению системы типов LLVM для устранения
этот недостаток.

Если программа безопасна с точки зрения типов в соответствии с приведенным выше определением, информация о типах может быть использована во время важных анализов.
такие как анализ псевдонимов и преобразование реорганизации структуры данных, могут быть безопасно применены к нему. 
Если программа
полностью типобезопасный, его код LLVM может использовать инструкцию getelementptr для всех арифметических операций с указателями без
требующие любых небезопасных бросков. Например, для языка с арифметикой указателей наивная компиляция может привести к тому, что тип
нарушения. Например, рассмотрим этот код C:
```
int *A = ..., *P = A;
while (P != A+Size) {
*P = *P + 1;
++P; /* Pointer arithmetic! */
}
```
Арифметика указателя в последнем операторе может быть изначально скомпилирована в этот фрагмент кода LLVM:
```
%tmp = cast int* %P1 to long                         ; Convert pointer to integral type for add
%tmp2 = add long %tmp, 4                             ; Add offset to integral value
%P2 = cast long %tmp2 to int*                        ; Convert result back to pointer (unsafe!)
```
Приведение %P2 не является типобезопасным, поскольку произвольное значение приводится к указателю, и хотя в этом случае
Результат оказывается допустимым целочисленным указателем, компилятор не может знать об этом без дальнейшего анализа. В случае выше,
однако простой анализ индукционной переменной может преобразовать код для использования индексации массива или функции getelementptr.
можно использовать для прямой навигации по массиву безопасным для типов образом:
```
%P2 = getelementptr int* %P1, uint 1                 ; Get pointer to next integer
```
На практике многие программы на C полностью или в основном типобезопасны в соответствии с приведенным выше определением, и большинство
небезопасные операции приведения можно исключить из таких программ с помощью простых преобразований. Тем не менее там
некоторые программы, которые по своей природе должны использовать небезопасные операции (такие как приведение определенного целого числа, представляющего
адрес аппаратного устройства с отображением памяти в указатель), который нельзя преобразовать для использования getelementptr
инструкция. В этих случаях инструкция приведения в LLVM дает важную информацию о том, когда система типов
нарушения, улучшая анализ и позволяя прямо определить, безопасно ли преобразование.

## Явное выделение памяти
Одни из самых сложных для адекватной оптимизации программ — это программы с ограниченным доступом к памяти, которые широко используют ресурсы памяти.
куча и сложные структуры данных. Чтобы лучше представить шаблоны распределения памяти компилятору, мы добавили типизированные
инструкции по выделению памяти в набор инструкций. Инструкция malloc выделяет один или несколько элементов
определенного типа в куче, возвращая типизированный указатель на новую память. Инструкция free освобождает память
выделяется с помощью инструкции malloc5. Инструкция alloca аналогична malloc, за исключением того, что она выделяет
память в кадре стека текущей функции вместо кучи, и память автоматически освобождается
по возвращении из функции.
Эти инструкции необходимы для сохранения безопасности типов нашего представления (обычный C malloc()
функция возвращает нетипизированный указатель, который необходимо привести к соответствующему типу), и включили новые преобразования
без них было бы очень сложно (например, безопасное автоматическое выделение пула и реорганизация структуры данных
для программ на C).

## Вызовы функций и исключения
LLVM предоставляет две инструкции вызова функций, которые абстрагируются от соглашений о вызовах базовой машины.
упростить анализ программы и обеспечить поддержку обработки исключений. Простая инструкция вызова принимает указатель
в вызываемую функцию, а также аргументы для передачи (которые передаются по значению). Хотя все инструкции по вызову
возьмите указатель функции для вызова (и, таким образом, кажутся косвенными вызовами), для прямых вызовов аргумент является глобальным
константа (адрес функции). Этот распространенный случай можно легко определить, просто проверив, является ли указатель глобальной константой. Вторая инструкция вызова функции, предоставляемая LLVM, — это инструкция вызова, которая используется для
языки с обработкой исключений.

LLVM реализует механизм раскручивания стека [24] для обработки исключений с нулевой стоимостью. Модель обработки исключений с «нулевой стоимостью» указывает на то, что наличие обработки исключений не приводит к выполнению дополнительных инструкций процессором.
программа, если исключения не выбрасываются. Когда возникает исключение, стек раскручивается, проходя пошагово адреса возврата вызовов функций в стеке. Среда выполнения LLVM хранит статическую карту адресов возврата для исключений.
блоки обработчиков, которые используются для вызова обработчиков при раскручивании.

Чтобы построить эту статическую карту информации об обработчике, LLVM предоставляет инструкцию вызова, которая принимает
метка обработчика исключений в дополнение к указателю на функцию и операндам-аргументам обычной инструкции вызова.
Когда происходит генерация кода, адрес возврата инструкции вызова связан с обработчиком исключений.
указанная метка, позволяющая вызывать процедуру обработки/очистки исключений, когда кадр стека раскручивается.
Инструкция Invoke способна представлять исключения высокого уровня непосредственно в LLVM, используя только низкоуровневые
концепции (адрес возврата в карту обработчиков). Это также делает LLVM независимым от исключения исходных языков.
работа с семантикой. В этом представлении края исключений указываются напрямую и видны для платформы LLVM.
предотвращение ненужной пессимизации оптимизаций, когда возможны исключения. Этот пример иллюстрирует
вызвать инструкцию в контексте C++:
```
...
Class Object; // Has a destructor
func(); // Could throw
...
```
Ключевой момент, который следует отметить в этом очень простом примере, заключается в том, что C++ гарантирует, что деструкторы стека, выделенные
объекты будут вызываться, если исключение распространяется через текущий кадр стека. В переводе на LLVM это
становится:
```
...
%Object = alloca %Class                            ; Stack allocate object
; ... call constructor on %Object ...
invoke void %func()
to label %Ok except label %Exception
Ok:
; ... execution continues...
Exception:
; ... call destructor on %Object ...
call void %rethrow()                               ; Rethrow current exception
```
Инструкция вызова связывает обработчик исключений для вызова, если исключение распространяется через вызываемый объект.
функция. В этом примере это используется для вызова деструктора локального объекта. В контексте языка Java
(который не должен вызывать деструкторы при раскручивании), инструкция вызова используется для разблокировки блокировок, которые
полученные с помощью синхронизированных блоков или методов. На любом языке предложение catch будет реализовано в терминах
назначения исключения.

Хотя в настоящее время у нас нет интерфейса, использующего поддержку обработки исключений, встроенную в LLVM, все наши
оптимизация и преобразование учитывают исключительные границы потока управления, и наши модульные тесты работают так, как задумано.

## Несколько особых случаев
Возможность спроектировать наше представление, не заботясь об унаследованном коде компилятора, дала нам возможность спроектировать
простой ортогональный набор инструкций с несколькими особыми случаями для рассмотрения. Особые случаи в представлениях усложняют
тонкие преобразования, которые затрудняют их написание и подвержены гнусным ошибкам. Некоторые примеры
функции особого случая, которые не нужны в LLVM, — это оператор «адреса» и инструкция «косвенного вызова».

В LLVM все адресуемые объекты (выделенные в стеке локальные переменные, глобальные переменные, функции, динамически выделяемая память) выделяются явно. Локальные переменные, выделенные в стеке, выделяются явно с помощью инструкции alloca (которая
аналог malloc, который выделяет память из стека, а не из кучи). Функции и глобальные переменные
(совместно именуемые «глобальными значениями») объявляют области статически выделенной памяти, доступ к которым осуществляется через
адрес объекта (имя глобального значения относится к адресу). Память, выделенная кучей, очевидно
выделяется инструкцией malloc. Поскольку к объектам памяти всегда обращаются по их адресу, оператор «addressof» просто не нужен. Это представление также упрощает анализ доступа к памяти, так как не может быть
неявный доступ к памяти. Весь трафик памяти происходит, когда выполняются инструкции «загрузить» и «сохранить».

LLVM также не имеет инструкции «косвенного вызова» в дополнение к обычной
инструкция вызова. Это связано с тем, что стандартная инструкция вызова принимает указатель на аргумент функции вместе с
остальные аргументы передать функции, а не функции как специальной части инструкции. Эффективно это
означает, что все вызовы функций представлены как косвенные вызовы, хотя у большинства из них явно указан адрес функции.
передается в качестве первого аргумента.

Мы решили сделать так, чтобы возможности инструкции call по умолчанию допускали непрямые вызовы, чтобы уменьшить размер
набор инструкций (нам пришлось бы добавить «косвенный вызов», а также инструкцию «косвенный вызов», чтобы обеспечить общий
косвенные вызовы в наивной манере) и поощрять преобразования для реализации общего случая перед специальным
case (который по-прежнему легко поддерживать). В этом примере показано, как глобальные значения (в данном случае функции) обрабатываются как
указатели на их объявленный тип:
```
void %func(int) { ... }
void %calltest(void (int)* %FuncPtr, int %Val) {
; Call the "func" function directly, passing in Val as its argument...
call void (int)* %func(int %Val)
; Call the function pointer, passing in Val as its argument...
call void (int)* %FuncPtr(int %Val)
ret void
}
int %main() {
; Invoke the "calltest" function, passing in "func" as a function pointer...
call void (void(int)*, int)* %calltest(void (int)* %func, int 42)
ret int 0
}
```
Многие другие небольшие функции, такие как две вышеприведенные, объединены вместе, чтобы значительно упростить написание и
поддерживать анализы и преобразования для различных целей. Из-за этого наша инфраструктура компилятора легко
расширился и очень быстро развил мощные функции.

## Связь с другими понятиями
[llvm](https://github.com/vernikkkkkkkkkkkkkkkkkkk/concept_new/blob/main/concept/low%20level%20virtual%20machine.md)
