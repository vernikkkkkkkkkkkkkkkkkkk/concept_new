## Набор команд виртуальной машины низкого уровня
набор команд виртуальной машины низкого уровня (eng:command set low level virtual machine)
## Описание
Виртуальный набор инструкций LLVM предназначен для низкоуровневого представления с поддержкой высокоуровневого анализа и
преобразования. Для достижения этих целей он предоставляет обширную информацию независимого от языка типа обо всех значениях.
В программе, выделяет память непосредственно компилятору и специально разработан, чтобы иметь несколько специальных
случаи. В этом разделе сначала представлен обзор архитектуры LLVM, а затем обсуждаются основные функции
Виртуальный набор инструкций LLVM.
## Обзор архитектуры LLVM
Набор инструкций LLVM представляет собой виртуальную архитектуру, которая захватывает ключевые операции обычных процессоров,
но избегает специфических для машины ограничений, таких как физические регистры, конвейеры, соглашения о низкоуровневых вызовах или ловушки.
LLVM предоставляет бесконечный набор типизированных виртуальных регистров, которые могут хранить значения примитивных типов (целочисленные, плавающие
точки или значения указателя). Виртуальные регистры имеют форму Static Single Assignment (SSA), которая широко используется
представление для оптимизации компилятора. 
Программы LLVM передают значения между виртуальными регистрами и памятью исключительно посредством операций загрузки и сохранения,
с помощью типизированных указателей.
Память разделена на глобальную область, стек и кучу (где функции в программе рассматриваются как глобальные объекты). Объекты в стеке и куче выделяются с помощью инструкций alloca и malloc.
соответственно, и доступ к ним осуществляется через значения указателя, возвращаемые этими операциями. Объекты стека размещаются в
кадр стека текущей функции и автоматически освобождаются, когда управление покидает функцию. Объекты кучи должны
быть явно освобожден с помощью свободной инструкции.
Обратите внимание, что LLVM — это виртуальный набор инструкций: он не определяет функции среды выполнения и операционной системы, такие как ввод-вывод,
управление памятью (в частности сборка мусора), сигналы и многие другие. Некоторые вопросы, которые относятся к
набор инструкций и может быть добавлен в будущем, включая поддержку мультимедийных инструкций (например, пакетных операций),
предикативные инструкции и явный параллелизм.
## Трехадресный код
Трехадресный код был предпочтительным представлением для архитектур RISC и независимого от языка компилятора.
оптимизация на долгие годы. По духу он очень близок к машинному коду, с небольшим количеством простых, ортогональных
операции. Трехадресный код можно легко сжать, что позволяет создавать файлы LLVM высокой плотности.
Большинство операций LLVM, включая все арифметические и логические операции, выполняются в 3-адресной форме, т. е. они занимают один адрес.
или два операнда и дают один результат. LLVM включает в себя стандартный и довольно ортогональный набор арифметических и
логические операции: add, sub, mul, div, rem, not, and, or, xor, shl, shr и setcc. Последний (setcc)
на самом деле набор инструкций сравнения с различными операторами (например, seteq, setlt и т. д.), которые производят
логический результат. Помимо простых двоичных инструкций, некоторые инструкции могут принимать 0, 3 и более или переменное число.
операндов. Важные примеры включают инструкции вызова и инструкцию phi, используемую для перевода кода в форму SSA.
Ключевым моментом является то, что инструкции LLVM полиморфны, т. е. одна инструкция, такая как add, может работать с несколькими командами.
различные типы операндов. Это значительно уменьшает количество различных кодов операций. В частности, мы не требуем
разные коды операций для операций над целыми числами со знаком и без знака, значениями с плавающей запятой одинарной или двойной точности,
арифметические или логические сдвиги и т. д. Типы операндов автоматически определяют семантику операции и
тип результата и должен следовать строгим правилам типов.
Например, вот несколько простых операций LLVM:
#%X = div int 4, 9 ; Signed integer division
%Y = div uint 12, 4 ; Unsigned integer division
%cond = seteq int %X, 8 ; Produces a boolean value
br bool %cond, label %True, label %False
True:
...#
